# -*- coding: utf-8 -*-
"""
Created on Mon Feb  3 08:58:16 2020

@author: Stolar

This modules contain the parameters of the anmysis and simulation handled
by mcsim.py;It is also used by mcsim_plot and mcsim_res.
- det_level (0.9): Fraction for declaring a detection above the 3 or 5 sigma thresholds
- alpha (0.2) : related to the number of off N zones in the on-off analysis, alpha = 1/N
- on_size : the on (and off-) region radius
- offset : the on and off region distance to the center of the field of view (Should be greater than the on-size radius)
- containment : the fraction of the background area corresponding to on/off regions
- n_lima_min (10) : Count number below which Li & Ma formula cannot be trusted anymore
- fov (5.*u.deg) : Full Field-of-view for the sky map
- binsize (0.125*u.deg) : square pixel length for the sky map

"""
import astropy.units as u
import numpy as np

det_level   = 0.9 # Fraction declaring a detection above the 3,5 sig. threshold
nLiMamin    = 10  # Count number below which Li&Ma cannot be trusted anymore
alpha       = 0.2 # 5 zones (1/0.2) to define the off region for B estimate

containment = 0.68

on_size     = { "FullArray"   : 0.4*u.deg,
                "4LSTs09MSTs" : 0.4*u.deg,
                "LST"         : 0.4*u.deg,
                "MST"         : 0.25*u.deg,
                "14MSTs37SSTs": 0.25*u.deg } # On region size, was 0.2

offset      = { "FullArray"   : 0.75*u.deg,
                "4LSTs09MSTs" : 0.75*u.deg,
                "LST"         : 0.75*u.deg,
                "MST"         : 0.5*u.deg,
                "14MSTs37SSTs": 0.5*u.deg} # Offset, so that regions do not overlap
# on_size     = 1.3*u.deg # On region size
# offset      = 1.3*u.deg # Offset

# This "optimal" spacing was generated by hand from the output of the function
# below (generate_E_edges). It ensures that the critical IRF thresholds are 
# in the list for an efficient masking

# Warning: an axis starting below the min generated energy creates problem
# in the background evaluation
# I have removed the 1.00000000e+01 GeV edge, and even start at the minimum
# authorised energy (low zenith)


erec_edges = { 
"FullArray":    np.asarray([30, 40, 60, 110., 200, 350, 700,
                         1300, 2400, 4400, 8000, 15000])*u.GeV,
"4LSTs09MSTs":  np.asarray([30, 40, 60, 110., 200, 350, 700,
                         1300, 2400, 4400, 8000, 15000])*u.GeV,
"LST":          np.asarray([30, 40, 60, 110., 200, 350, 700,
                         1300, 2400, 4400, 8000, 15000])*u.GeV,
"MST":          np.asarray([30, 40, 60, 110., 200, 350, 700,
                         1300, 2400, 4400, 8000, 15000])*u.GeV,
"14MSTs37SSTs": np.asarray([30, 40, 60, 110., 200, 350, 700,
                         1300, 2400, 4400, 8000, 15000])*u.GeV
             }
# erec_edges = { 
# "FullArray":    np.asarray([30, 40, 56, 110., 200, 316, 562,
#                          1000, 1778, 3162, 5623, 10000, 15000])*u.GeV,
# "4LSTs09MSTs":  np.asarray([30, 40, 56, 110., 200, 316, 562,
#                          1000, 1778, 3162, 5623, 10000, 15000])*u.GeV,
# "LST":          np.asarray([30, 40, 56, 110., 200, 316, 562,
#                          1000, 1778, 3162, 5623, 10000, 15000])*u.GeV,
# "MST":          np.asarray([30, 40, 56, 110., 200, 316, 562,
#                          1000, 1778, 3162, 5623, 10000, 15000])*u.GeV,
# "14MSTs37SSTs": np.asarray([30, 40, 56, 110., 200, 316, 562,
#                           1000, 1778, 3162, 5623, 10000, 15000])*u.GeV
#              }

safe_margin = 1*u.GeV
# erec_min = {"FullArray"  :    {"20deg":  30*u.GeV -safe_margin,
#                                "40deg":  40*u.GeV -safe_margin,
#                                "60deg": 110*u.GeV -safe_margin
#                               },
#             "4LSTs09MSTs":    {"20deg":  30*u.GeV -safe_margin,
#                                "40deg":  40*u.GeV -safe_margin,
#                                "60deg": 110*u.GeV -safe_margin
#                               },
#              "LST"       :    {"20deg":  30*u.GeV -safe_margin,
#                                "40deg":  40*u.GeV -safe_margin,
#                                "60deg": 110*u.GeV -safe_margin
#                               },
#              "MST"       :    {"20deg":  56*u.GeV -safe_margin, # was 110
#                                "40deg":  56*u.GeV -safe_margin, # was 110
#                                "60deg": 200*u.GeV -safe_margin
#                               },             
#              "14MSTs37SSTs" : {"20deg":  56*u.GeV -safe_margin, # was 110
#                                "40deg": 110*u.GeV -safe_margin, # was 110
#                                "60deg": 316*u.GeV -safe_margin
#                               }
#             }

erec_min = {"FullArray"  :    {"20deg":  30*u.GeV -safe_margin,
                               "40deg":  40*u.GeV -safe_margin,
                               "60deg": 110*u.GeV -safe_margin
                              },
            "4LSTs09MSTs":    {"20deg":  30*u.GeV -safe_margin,
                               "40deg":  40*u.GeV -safe_margin,
                               "60deg": 110*u.GeV -safe_margin
                              },
             "LST"       :    {"20deg":  30*u.GeV -safe_margin,
                               "40deg":  40*u.GeV -safe_margin,
                               "60deg": 110*u.GeV -safe_margin
                              },
             "MST"       :    {"20deg":  60*u.GeV -safe_margin, # was 110
                               "40deg":  60*u.GeV -safe_margin, # was 110
                               "60deg": 200*u.GeV -safe_margin
                              },             
             "14MSTs37SSTs" : {"20deg":  60*u.GeV -safe_margin, # was 110
                               "40deg": 110*u.GeV -safe_margin, # was 110
                               "60deg": 350*u.GeV -safe_margin
                              }
            }


erec_max = {"20deg": 10*u.TeV + safe_margin,
            "40deg": 10*u.TeV + safe_margin,
            "60deg": 10*u.TeV + safe_margin}

fov        = 5.*u.deg    # Full Field-of-view
binsize    = 0.125*u.deg #  bin size if building a map
# fov      = 2.5*u.deg # Quicker dirty tests
# binsize  = 0.5*u.deg # Quicker dirty tests


#------------------------------------------------------------------------------
def generate_E_edges(E1=10*u.GeV, E2=100*u.TeV, 
                     subarray="FullArray", nperdecade=4):
    """
    Generate energy edges including the reconstructed energy thresholds.
    Just copy tthe output to the code and rearrange the values to remove too
    too narrow bins.

    Parameters
    ----------
    E1 : Quantity, optional
        Lower bound. The default is 10*u.GeV.
    E2 : Quantity, optional
        Upper bound. The default is 100*u.TeV.
    nperdecade : Integer, optional
        Default number of bins per decade. The default is 4.

    Returns
    -------
    None.

    """    
    unit_ref = E1.unit
    Emin = E1.to(unit_ref).value
    Emax = E2.to(unit_ref).value

    # Compute the number of bins to be generated from the number of decades
    ndecade = np.log10(Emax/Emin) # Number of decades covered
    nbin = ndecade*nperdecade
    print(" ARRAY  : ",subarray)
    print("Total number of bins =",nbin)
    e_edges = np.logspace(np.log10(Emin),np.log10(Emax),int(nbin+1))*unit_ref
    print("Initial edging :")
    print(e_edges)

    # Add critical values to the array
    e_critical = [e.to(unit_ref).value for e in erec_min[subarray].values()]*unit_ref
    e_edges = np.append(e_edges, e_critical)
    e_critical = [e.to(unit_ref).value for e in erec_max.values()]*unit_ref
    e_edges = np.append(e_edges, e_critical)
    
    print("Final edging - indicative (copy this and rearrange if needed):")
    print(e_edges)

    return

###############################################################################
if __name__ == "__main__":
    
    generate_E_edges(E1=60*u.GeV,E2=15*u.TeV,nperdecade=4)
