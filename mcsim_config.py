# -*- coding: utf-8 -*-
"""
Created on Mon Feb  3 08:58:16 2020

@author: Stolar

This modules contain the parameters of the anmysis and simulation handled
by mcsim.py;It is also used by mcsim_plot and mcsim_res.
- det_level (0.9): Fraction for declaring a detection above the 3 or 5 sigma thresholds
- alpha (0.2) : related to the number of off N zones in the on-off analysis, alpha = 1/N
- on_size : the on (and off-) region radius
- offset : the on and off region distance to the center of the field of view (Should be greater than the on-size radius)
- containment : the fraction of the background area corresponding to on/off regions
- n_lima_min (10) : Count number below which Li & Ma formula cannot be trusted anymore
- fov (5.*u.deg) : Full Field-of-view for the sky map
- binsize (0.125*u.deg) : square pixel length for the sky map

"""
import astropy.units as u
import numpy as np

det_level   = 0.9 # Fraction declaring a detection above the 3,5 sig. threshold
nLiMamin    = 10  # Count number below which Li&Ma cannot be trusted anymore
alpha       = 0.2 # 5 zones (1/0.2) to define the off region for B estimate

containment = 0.68

on_size     = { "FullArray"        : 0.4*u.deg,
                "4LSTs09MSTs"      : 0.4*u.deg,
                "LST"              : 0.4*u.deg,
                "MST"              : 0.25*u.deg,
                "14MSTs37SSTs"     : 0.25*u.deg,
                "4LSTs14MSTs40SSTs": 0.4*u.deg,} # On region size, was 0.2

offset      = { "FullArray"        : 0.75*u.deg,
                "4LSTs09MSTs"      : 0.75*u.deg,
                "LST"              : 0.75*u.deg,
                "MST"              : 0.5*u.deg,
                "14MSTs37SSTs"     : 0.5*u.deg,
                "4LSTs14MSTs40SSTs": 0.75*u.deg,
                } # Offset, so that regions do not overlap

# This "optimal" spacing was generated by hand from the output of the function
# below (generate_E_edges). It ensures that the critical IRF thresholds are 
# in the list for an efficient masking
# Warning: an axis starting below the min generated energy creates problem
# in the background evaluation
# I have removed the 1.00000000e+01 GeV edge, and even start at the minimum
# authorised energy (low zenith)


# This is a sparse but regular E binning not well suited for spectra analysis
# Former spacing was:
erec_sparse  = np.asarray([30, 40, 60, 110, 200, 350, 700,
                         1300, 2400, 4400, 8000, 15000])*u.GeV

# This is a denser E-binning suitable for spectral analysis
erec_spectral = np.asarray([  30.,   40.,   50.,   60.,   80.,  110.,  160., \
                             200.,  250.,  350.,  400.,  530.,  670.,  850., \
                            1082., 1374., 1745., 2216., 2815., 3575., 4540., \
                            5766.,  7323., 9300., 11811.,  15000.])*u.GeV

    # Define the reconstrcuted energy bins for each subarray
erec_edges = {
"FullArray"        : erec_spectral, # Omega
"4LSTs09MSTs"      : erec_spectral, # Alpha
"LST"              : erec_spectral,
"MST"              : erec_spectral,
"14MSTs37SSTs"     : erec_spectral, # Alpha
"4LSTs14MSTs40SSTs": erec_spectral  # Beta
}

safe_margin = 1*u.GeV
erec_min = {"FullArray"         : {"20deg":  30*u.GeV -safe_margin,
                                   "40deg":  40*u.GeV -safe_margin,
                                   "60deg": 110*u.GeV -safe_margin
                                  },
            "4LSTs09MSTs"       : {"20deg":  30*u.GeV -safe_margin,
                                   "40deg":  40*u.GeV -safe_margin,
                                   "60deg": 110*u.GeV -safe_margin
                                  },
             "LST"              : {"20deg":  30*u.GeV -safe_margin,
                                   "40deg":  40*u.GeV -safe_margin,
                                   "60deg": 110*u.GeV -safe_margin
                                  },
             "MST"              : {"20deg":  60*u.GeV -safe_margin, # was 110
                                   "40deg":  60*u.GeV -safe_margin, # was 110
                                   "60deg": 200*u.GeV -safe_margin
                                  },             
             "14MSTs37SSTs"     : {"20deg":  60*u.GeV -safe_margin, # was 110
                                   "40deg": 110*u.GeV -safe_margin, # was 110
                                   "60deg": 350*u.GeV -safe_margin
                                  },
             "4LSTs14MSTs40SSTs": {"20deg":  30*u.GeV -safe_margin, # was 110
                                   "40deg":  40*u.GeV -safe_margin, # was 110
                                   "60deg": 110*u.GeV -safe_margin
                                   }
             }


erec_max = {"20deg": 10*u.TeV + safe_margin,
            "40deg": 10*u.TeV + safe_margin,
            "60deg": 10*u.TeV + safe_margin}

# fov        = 5.*u.deg    # Full Field-of-view - quick tests: 2.5*u.deg
# binsize    = 0.125*u.deg #  bin size if building a map  - quick test: 0.5*u.deg

#------------------------------------------------------------------------------
def generate_E_edges(E1=10*u.GeV, E2=100*u.TeV, 
                     subarray="FullArray", nperdecade=4):
    """
    Generate energy edges including the reconstructed energy thresholds.
    Just copy tthe output to the code and rearrange the values to remove too
    too narrow bins.

    Parameters
    ----------
    E1 : Quantity, optional
        Lower bound. The default is 10*u.GeV.
    E2 : Quantity, optional
        Upper bound. The default is 100*u.TeV.
    nperdecade : Integer, optional
        Default number of bins per decade. The default is 4.

    Returns
    -------
    None.

    """    
    unit_ref = E1.unit
    Emin = E1.to(unit_ref).value
    Emax = E2.to(unit_ref).value

    # Compute the number of bins to be generated from the number of decades
    ndecade = np.log10(Emax/Emin) # Number of decades covered
    nbin = ndecade*nperdecade
    print(" ARRAY  : ",subarray)
    print("Total number of bins =",nbin)
    e_edges = np.logspace(np.log10(Emin),np.log10(Emax),int(nbin+1))*unit_ref
    print("Initial edging :")
    print(e_edges)

    # Add critical values to the array
    e_critical = [e.to(unit_ref).value for e in erec_min[subarray].values()]*unit_ref
    e_edges = np.append(e_edges, e_critical)
    e_critical = [e.to(unit_ref).value for e in erec_max.values()]*unit_ref
    e_edges = np.append(e_edges, e_critical)
    
    print("Final edging - indicative (copy this and rearrange if needed):")
    print(e_edges)

    return

###############################################################################
if __name__ == "__main__":
    
    generate_E_edges(E1=30*u.GeV,E2=15*u.TeV,nperdecade=10)
